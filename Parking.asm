!to "parking.prg",cbm

;SID Notes
SID_C_0_H             = $01
SID_C_0_L             = $0C
SID_CS_0_H            = $01
SID_CS_0_L            = $1C
SID_D_0_H             = $01
SID_D_0_L             = $2D
SID_DS_0_H            = $01
SID_DS_0_L            = $3E
SID_E_0_H             = $01
SID_E_0_L             = $51
SID_F_0_H             = $01
SID_F_0_L             = $66
SID_FS_0_H            = $01
SID_FS_0_L            = $7B
SID_G_0_H             = $01
SID_G_0_L             = $91
SID_GS_0_H            = $01
SID_GS_0_L            = $A9
SID_A_0_H             = $01
SID_A_0_L             = $C3
SID_AS_0_H            = $01
SID_AS_0_L            = $DD
SID_B_0_H             = $01
SID_B_0_L             = $FA

SID_C_1_H             = $02
SID_C_1_L             = $18
SID_CS_1_H            = $02
SID_CS_1_L            = $38
SID_D_1_H             = $02
SID_D_1_L             = $5A
SID_DS_1_H            = $02
SID_DS_1_L            = $7D
SID_E_1_H             = $02
SID_E_1_L             = $A3
SID_F_1_H             = $02
SID_F_1_L             = $CC
SID_FS_1_H            = $02
SID_FS_1_L            = $F6
SID_G_1_H             = $03
SID_G_1_L             = $23
SID_GS_1_H            = $03
SID_GS_1_L            = $53
SID_A_1_H             = $03
SID_A_1_L             = $86
SID_AS_1_H            = $03
SID_AS_1_L            = $BB
SID_B_1_H             = $03
SID_B_1_L             = $F4

SID_C_2_H             = $04
SID_C_2_L             = $30
SID_CS_2_H            = $04
SID_CS_2_L            = $70
SID_D_2_H             = $04
SID_D_2_L             = $B4
SID_DS_2_H            = $04
SID_DS_2_L            = $FB
SID_E_2_H             = $05
SID_E_2_L             = $47
SID_F_2_H             = $05
SID_F_2_L             = $98
SID_FS_2_H            = $05
SID_FS_2_L            = $ED
SID_G_2_H             = $06
SID_G_2_L             = $47
SID_GS_2_H            = $06
SID_GS_2_L            = $A7
SID_A_2_H             = $07
SID_A_2_L             = $0C
SID_AS_2_H            = $07
SID_AS_2_L            = $77
SID_B_2_H             = $07
SID_B_2_L             = $E9

SID_C_3_H             = $08
SID_C_3_L             = $61
SID_CS_3_H            = $08
SID_CS_3_L            = $E1
SID_D_3_H             = $09
SID_D_3_L             = $68
SID_DS_3_H            = $09
SID_DS_3_L            = $F7
SID_E_3_H             = $0A
SID_E_3_L             = $8F
SID_F_3_H             = $0B
SID_F_3_L             = $30
SID_FS_3_H            = $0B
SID_FS_3_L            = $DA
SID_G_3_H             = $0C
SID_G_3_L             = $8F
SID_GS_3_H            = $0D
SID_GS_3_L            = $4E
SID_A_3_H             = $0E
SID_A_3_L             = $18
SID_AS_3_H            = $0E
SID_AS_3_L            = $EF
SID_B_3_H             = $0F
SID_B_3_L             = $D2

SID_C_4_H             = $10
SID_C_4_L             = $C3
SID_CS_4_H            = $11
SID_CS_4_L            = $C3
SID_D_4_H             = $12
SID_D_4_L             = $D1
SID_DS_4_H            = $13
SID_DS_4_L            = $EF
SID_E_4_H             = $15
SID_E_4_L             = $1F
SID_F_4_H             = $16
SID_F_4_L             = $60
SID_FS_4_H            = $17
SID_FS_4_L            = $BF
SID_G_4_H             = $19
SID_G_4_L             = $1E
SID_GS_4_H            = $1A
SID_GS_4_L            = $9C
SID_A_4_H             = $1C
SID_A_4_L             = $31
SID_AS_4_H            = $1D
SID_AS_4_L            = $DF
SID_B_4_H             = $1F
SID_B_4_L             = $A5

SID_C_5_H             = $21
SID_C_5_L             = $87
SID_CS_5_H            = $23
SID_CS_5_L            = $86
SID_D_5_H             = $25
SID_D_5_L             = $A2
SID_DS_5_H            = $27
SID_DS_5_L            = $DF
SID_E_5_H             = $2A
SID_E_5_L             = $3E
SID_F_5_H             = $2C
SID_F_5_L             = $C1
SID_FS_5_H            = $2F
SID_FS_5_L            = $6B
SID_G_5_H             = $32
SID_G_5_L             = $3C
SID_GS_5_H            = $35
SID_GS_5_L            = $39
SID_A_5_H             = $38
SID_A_5_L             = $63
SID_AS_5_H            = $3B
SID_AS_5_L            = $BE
SID_B_5_H             = $3F
SID_B_5_L             = $4B

SID_C_6_H             = $43
SID_C_6_L             = $0F
SID_CS_6_H            = $47
SID_CS_6_L            = $0C
SID_D_6_H             = $4B
SID_D_6_L             = $45
SID_DS_6_H            = $4F
SID_DS_6_L            = $BF
SID_E_6_H             = $54
SID_E_6_L             = $7D
SID_F_6_H             = $59
SID_F_6_L             = $83
SID_FS_6_H            = $5E
SID_FS_6_L            = $D6
SID_G_6_H             = $64
SID_G_6_L             = $79
SID_GS_6_H            = $6A
SID_GS_6_L            = $73 
SID_A_6_H             = $70
SID_A_6_L             = $C7
SID_AS_6_H            = $77
SID_AS_6_L            = $7C
SID_B_6_H             = $7E
SID_B_6_L             = $97

SID_C_7_H             = $86
SID_C_7_L             = $1E
SID_CS_7_H            = $8E
SID_CS_7_L            = $18
SID_D_7_H             = $96
SID_D_7_L             = $8B
SID_DS_7_H            = $9F
SID_DS_7_L            = $7E
SID_E_7_H             = $A8
SID_E_7_L             = $FA
SID_F_7_H             = $B3
SID_F_7_L             = $06
SID_FS_7_H            = $BD
SID_FS_7_L            = $AC
SID_G_7_H             = $C8
SID_G_7_L             = $F3
SID_GS_7_H            = $D4
SID_GS_7_L            = $E6
SID_A_7_H             = $E1
SID_A_7_L             = $8F
SID_AS_7_H            = $EE
SID_AS_7_L            = $F8
SID_B_7_H             = $FD
SID_B_7_L             = $2E

COLOR_BLACK         = $00          ;schwarz
COLOR_WHITE         = $01          ;weiß
COLOR_RED           = $02          ;rot
COLOR_CYAN          = $03          ;türkis
COLOR_PURPLE        = $04          ;lila
COLOR_GREEN         = $05          ;grün
COLOR_BLUE          = $06          ;blau
COLOR_YELLOW        = $07          ;gelb
COLOR_ORANGE        = $08          ;orange
COLOR_BROWN         = $09          ;braun
COLOR_PINK          = $0a          ;rosa
COLOR_DARKGREY      = $0b          ;dunkelgrau
COLOR_GREY          = $0c          ;grau
COLOR_LIGHTGREEN    = $0d          ;hellgrün
COLOR_LIGHTBLUE     = $0e          ;hellblau
COLOR_LIGHTGREY     = $0f          ;hellgrau

VICBASE             = $d000
VICCHARSET          = $d018
VICBORDERCOLOR      = $d020
VICBACKGROUNDCOLOR  = $d021

SCREENRAMADR        = $0400
COLORRAMADR         = $d800
CIA1_A              = $dc00
CIA1_B              = $dc01

AUTOSTACK           = $29C0

ZP_SCREENRAMADR     = $02
ZP_COLORRAMADR      = $04
ZP_SCREENTODRAW     = $06
ZP_COLORTODRAW      = $08
ZP_HILFSVAR01       = $0A
ZP_HILFSVAR02       = $0B
ZP_HILFSVAR03       = $0C
ZP_HILFSVAR04       = $0D
ZP_DIVISOR          = $0E
ZP_REMOVEDCARS      = $0F
ZP_COLORRAMADR02    = $10

ZP_SID_CHANNEL_1_Timer       = $20
ZP_SID_CHANNEL_1_Pat_Pos     = $21
ZP_SID_CHANNEL_1_Wave_Pos    = $22
ZP_SID_CHANNEL_1_Channel_Pos = $23
ZP_SID_CHANNEL_1_Pat_Addr_Hi = $24
ZP_SID_CHANNEL_1_Pat_Addr_Lo = $25

ZP_SID_CHANNEL_2_Timer       = $27
ZP_SID_CHANNEL_2_Pat_Pos     = $28
ZP_SID_CHANNEL_2_Wave_Pos    = $29
ZP_SID_CHANNEL_2_Channel_Pos = $2A
ZP_SID_CHANNEL_2_Pat_Addr_Hi = $2B
ZP_SID_CHANNEL_2_Pat_Addr_Lo = $2C

ZP_SID_CHANNEL_3_Timer       = $2E
ZP_SID_CHANNEL_3_Pat_Pos     = $2F
ZP_SID_CHANNEL_3_Wave_Pos    = $30
ZP_SID_CHANNEL_3_Channel_Pos = $31
ZP_SID_CHANNEL_3_Pat_Addr_Hi = $32
ZP_SID_CHANNEL_3_Pat_Addr_Lo = $33

ZP_SID_CHANNEL_3_Pulse_Lo = $34
ZP_SID_CHANNEL_3_Pulse_Hi = $35

ZP_PARKING_ROWS_L   = $50
ZP_PARKING_ROWS_H_S = $60
ZP_WAVETABLE        = $FC

INPUT_NONE          = $00
INPUT_JOY1          = $01
INPUT_JOY2          = $02
JOY_UP              = %00000001
JOY_DOWN            = %00000010
JOY_LEFT            = %00000100
JOY_RIGHT           = %00001000
JOY_FIRE            = %00010000

;*** Startadresse
*=$0801

;*** BASIC-Zeile
  !word main-2
  !word 2018
  !text $9E, " 2062", $00,$00,$00
  
main
  lda $01                               ;clear basic rom
  and #%11111110
  sta $01
  
  lda #$18
  sta VICCHARSET
  
  lda $d016                             ;Multicolor Textmode aktivieren
  ora #%00010000
  sta $d016
  
  ; set first and second multicolor
  lda #COLOR_LIGHTGREY
  sta $d022
  lda #COLOR_DARKGREY
  sta $d023
  
  ;get PAL / NTSC
.loop_line_count
  lda $d012
.loop_line_count_2
  cmp $d012
  beq .loop_line_count_2
  bmi .loop_line_count
  cmp #$37
  beq .found_pal
  
;.found NTSC
  lda #$1E
  sta gameTimeSlow
  lda #$0A
  sta gameTimeFast
  
  lda #07
  sta calc_note_length.loop_note_length+1
  
  lda #$02
  jmp .load_game
  
.found_pal
  lda #$00
.load_game
  jsr load_sid_notes
  jsr load_parking_rows
  jsr clear_sid
  jsr init_song_0
  jsr activateIRQs
  jsr showScreen_Title                  ;Startbildschirm anzeigen
  
gameMainLoop
  jsr checkInput
  jmp gameMainLoop
  rts                                   ;Zurück zum Basic
  
!zone load_sid_notes
load_sid_notes
  pha
  ldx #$05
  lda #<notetable
  sta ZP_SCREENTODRAW
  lda #>notetable
  sta ZP_SCREENTODRAW+1
  
.loop_notes
  pla
  tay
  pha
  lda (ZP_SCREENTODRAW),y
  sta ZP_HILFSVAR01
  iny
  lda (ZP_SCREENTODRAW),y
  ldy #$01
  sta (ZP_SCREENTODRAW),y
  dey
  lda ZP_HILFSVAR01
  sta (ZP_SCREENTODRAW),y
  
  ldy #$00
.loop_octaves
  lda (ZP_SCREENTODRAW),y
  iny
  asl
  sta ZP_HILFSVAR01
  lda (ZP_SCREENTODRAW),y
  rol
  iny
  iny
  sta (ZP_SCREENTODRAW),y
  dey
  lda ZP_HILFSVAR01
  sta (ZP_SCREENTODRAW),y
  cpy #$0A
  bne .loop_octaves
  
  lda #$0C
  jsr addToScreenToDraw
  
  dex
  bne .loop_notes
  pla
rts
  
!zone load_parking_rows
load_parking_rows
  ldx #$00
  ldy #$09
  lda #$04
  
  sta ZP_PARKING_ROWS_H_S
  lda #$52
  sta ZP_PARKING_ROWS_L
.loop
  tya
  pha
  
  lda ZP_PARKING_ROWS_H_S,x
  tay
  lda ZP_PARKING_ROWS_L,x
  inx
  clc
  adc #$50
  sta ZP_PARKING_ROWS_L,x
  tya
  adc #$00
  sta ZP_PARKING_ROWS_H_S,x
  
  pla
  tay
  
  dey
  bpl .loop

rts

!zone fillBoardWithRandomCars
fillBoardWithRandomCars
  ldy #$08
  
.loop_through_cars
  tya
  pha
  lda #$0B
  sta ZP_DIVISOR
  jsr rndTimer
  and #%01111111
  jsr getModulo
  asl
  asl
  asl
  asl
  sta carList+$1B
  
  lda #$09
  sta ZP_DIVISOR
  jsr rndTimer
  and #%01111111
  jsr getModulo
  ora carList+$1B
  sta carList+$1B

  lda #$04
  sta ZP_DIVISOR
  jsr rndTimer
  and #%01111111
  jsr getModulo
  sta carList+$1C
  
  lda #$06
  sta ZP_DIVISOR
  jsr rndTimer
  and #%01111111
  jsr getModulo
  clc
  adc #$0A
  sta carList+$1D
  
  lda #$01
  
  jsr drawCar
  
  pla
  tay
  dey
  bne .loop_through_cars
  
rts
  
;*******************************************************************************
;*** clears sid registers to start sid chip
;*******************************************************************************
!zone clear_sid
clear_sid
  lda #$00                        ;load 0 into A
  ldy #$18                        ;load 24 into Y
.loop_1
  sta $d400,Y                     ;store 0 in SID RAM ENTRY + Y bits
  dey                             ;decrease Y
  bpl .loop_1                     ;as long as Y is not 0 jump to loop_1
  
  rts                             ;return from subroutine (this time we also jump back to main)
  
;********************************************************************************************************************************
;*** Select input device and draw the parking ground
;********************************************************************************************************************************
!zone showScreen_Title
showScreen_Title
  
  lda #INPUT_NONE
  sta inputDevice
  
  jsr drawScreen
  
.wait
  jsr selectInputDevice
  lda inputDevice
  beq .wait
  
  rts

;********************************************************************************************************************************
;*** Set random cars into the next box
;********************************************************************************************************************************
!zone setRandomCars
setRandomCars
  lda maxCars
  sta ZP_DIVISOR
  jsr rndTimer
  and #%01111111
  jsr getModulo
  clc
  adc #$01
  tay
  
  lda #$DB
  sta ZP_COLORRAMADR+1
  lda #$B4
  sta ZP_COLORRAMADR
  sta ZP_SCREENRAMADR
  lda #$07
  sta ZP_SCREENRAMADR+1
  
  lda #$06
  sta ZP_DIVISOR
  
.loop
  jsr rndTimer
  and #%01111111
  jsr getModulo
  clc
  adc #$0A
  
  sta (ZP_COLORRAMADR),y
  lda #$41
  sta (ZP_SCREENRAMADR),y
  dey
  bne .loop
  rts

;********************************************************************************************************************************
;*** activate the raster IRQ
;********************************************************************************************************************************  
activateIRQs
  sei
  lda #<rasterIRQ
  sta $0314
  lda #>rasterIRQ
  sta $0315
  
  lda #$00
  sta $d012
  lda $d011
  and #%01111111
  sta $d011
  
  lda $d01a
  ora #%00000001
  sta $d01a
  cli

rts
  
;********************************************************************************************************************************
;*** Draws the parking ground and the player statistic boxes
;********************************************************************************************************************************
!zone drawScreen
drawScreen

  lda #COLOR_WHITE
  jsr fillScreenWithColor
  jsr drawTitleScreen
  
  rts



!zone drawHowTo
drawHowTo

  lda #$01
  sta title_state
  jsr fillScreenWithColor
  
  ; write label how to play
  lda #<how_to_label
  sta ZP_SCREENTODRAW
  lda #>how_to_label
  sta ZP_SCREENTODRAW+1
  
  lda #$40
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$05
  sta ZP_SCREENRAMADR+1
  lda #$D8
  sta ZP_COLORRAMADR+1
  
  ldx #COLOR_WHITE
  ldy #$27
  jsr write_text
  
  ; write label clear cars
  lda #$28
  jsr addToScreenToDraw
  
  lda #$50
  jsr addToScreenAndColorRam
  jsr write_text
  
  ; write label squares
  lda #$28
  jsr addToScreenToDraw
  
  lda #$50
  jsr addToScreenAndColorRam
  jsr write_text
  
  ; write label raise combo
  lda #$28
  jsr addToScreenToDraw

  lda #$50
  jsr addToScreenAndColorRam
  jsr write_text
  
  ; write label raise combo
  lda #$28
  jsr addToScreenToDraw

  lda #$50
  jsr addToScreenAndColorRam
  jsr write_text
  
  ; write label raise combo
  lda #$28
  jsr addToScreenToDraw

  lda #$50
  jsr addToScreenAndColorRam
  jsr write_text

rts

!zone drawTitleScreen
drawTitleScreen

  ldy #$A0
  
.loop_background
  
  lda #$6C
  sta $04EF,y
  sta $058F,y
  sta $062F,y
  
  cpy #$29
  bpl .next_loop_background
  lda #$6F
  sta $06cf,y
  
  lda #$6E
  sta $04c7,y
  
.next_loop_background
  dey
  bne .loop_background

;.drawTexts

  ; write label game by
  lda #<game_by_label
  sta ZP_SCREENTODRAW
  lda #>game_by_label
  sta ZP_SCREENTODRAW+1
  
  lda #$C6
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$07
  sta ZP_SCREENRAMADR+1
  lda #$DB
  sta ZP_COLORRAMADR+1
  ldy #$0A
  ldx #COLOR_WHITE
  jsr write_text
  
  ; write label fire
  lda #$0B
  jsr addToScreenToDraw
  
  lda #$B9
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$07
  sta ZP_SCREENRAMADR+1
  lda #$DB
  sta ZP_COLORRAMADR+1
  ldy #$03
  jsr write_text
  
  ; write label start
  lda #$04
  jsr addToScreenToDraw
  
  lda #$E2
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$07
  sta ZP_SCREENRAMADR+1
  lda #$DB
  sta ZP_COLORRAMADR+1
  ldy #$04
  jsr write_text
  
  
  ; write highscore
  lda #<highscore-$10
  sta ZP_SCREENTODRAW
  lda #>highscore
  sta ZP_SCREENTODRAW+1
  
  lda #$FC
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  lda #$D8
  sta ZP_COLORRAMADR+1
  
  ldx #$05
  ldy current_score
  
.loop_highscore
  lda #$10
  jsr addToScreenToDraw
  
  lda #$50
  jsr addToScreenAndColorRam
  
  dey
  cpy #$FF
  bne .continue_highscore
  
  sec
  lda ZP_SCREENRAMADR
  pha
  sbc #$01
  sta ZP_SCREENRAMADR
  lda ZP_SCREENRAMADR+1
  pha
  sbc #$00
  sta ZP_SCREENRAMADR+1
  
  lda #$6D
  ldy #$00
  sta (ZP_SCREENRAMADR),y
  pla
  sta ZP_SCREENRAMADR+1
  pla
  sta ZP_SCREENRAMADR
  lda #$FF
  tay
  
  
.continue_highscore
  txa
  pha
  tya
  pha
  ldx #COLOR_WHITE
  ldy #$0F
  jsr write_text
  pla
  tay
  pla
  tax
  
  dex
  bne .loop_highscore
  
;.adding cars to title

  ldx #$64
  lda #$2C
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  lda #$d8
  sta ZP_COLORRAMADR+1
  lda #$0A
  sta ZP_COLORTODRAW
  
  jsr drawParkingLot
  
  ldx #$68
  lda #$4B
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  
  jsr drawParkingLot
  
;.add title "Parking Ticket"

  ; X Position
  clc
  lda #$6B
  sta $D000
  adc #$18
  sta $D002
  adc #$18
  sta $D004
  adc #$18
  sta $D006
  adc #$18
  sta $D008
  adc #$18
  sta $D00A
  adc #$18
  sta $D00C
  
  ;Y Position
  
  lda #$32
  sta $D001
  sta $D003
  sta $D005
  sta $D007
  sta $D009
  sta $D00B
  sta $D00D
  
  ; Off some sprite options
  lda #$00
  sta $D010     ; X+255
  sta $D017     ; Double Height
  sta $D01B     ; Behind background
  sta $D01C     ; Multicolor
  sta $D01D     ; Double Width
  
  lda #$7F
  sta $D015     ; Visibility
  
  lda #COLOR_LIGHTBLUE
  sta $D027
  sta $D028
  sta $D029
  sta $D02A
  sta $D02B
  sta $D02C
  sta $D02D
  
  lda #$A0
  sta $07f8
  adc #$01
  sta $07f9
  adc #$01
  sta $07fa
  adc #$01
  sta $07fb
  adc #$01
  sta $07fc
  adc #$01
  sta $07fd
  adc #$01
  sta $07fe
  
  rts
  

;*******************************************************************************
;*** Fills borders and background with color in Akku and clears screen
;*******************************************************************************
!zone fillScreenWithColor         ;and again a zone for jump labels (in this funtion we also have our first jump label) :0D
fillScreenWithColor               ;name of the subroutine
  ;*** Make borders and background black
  tay
  lda #$00
  sta VICBORDERCOLOR              ;write A into the border color address
  sta VICBACKGROUNDCOLOR          ;write A into the background color address
                                  
  ;*** Clear Screen
  ldx #$FA                        ;load #$00 into X (# means we write a number, $ means it is a hex number, just $ without # means ram address)
.loop_clear                       ;our first jump label (it marks an address we can jump to later, so we don't need to hard code that address)
  lda #$00                        ;load #$E0 into A (thats a filled out rect in the Char-Rom)
  sta $03FF,x                     ;write that sign into a part of the screen ram ($0400 in the first loop, $0401 in the second, until $04ff)
  sta $04F9,x                     ;same for $0500
  sta $05F3,x                     ;the ,x means add X to the address written there sta means store A
  sta $06ED,x                     ;up until we reach $07ff
  
  tya                             ;now we transfer our color back from Y into A
  sta $D7FF,x                     ;same as above with the screen ram, but for the color ram
  sta $D8F9,x
  sta $D9F3,x
  sta $DAED,x
  dex                             ;we decrease X (our initial #$00 becomes #$ff, so it's an underflow?!)
  bne .loop_clear                 ;bne means branch on not equal (so we jump to our label if the last operation doesn't result in #$00)
                                  ;that means we have a loop that goes from X=#$00 over all 256 values back to #$00
  rts                             ;return from subroutine

  
;********************************************************************************************************************************
;*** Draws the parking lines to the ground
;********************************************************************************************************************************
!zone drawParkingLines
drawParkingLines
  
  ; set parking ground lines
  lda #$22
  pha
  lda #$20
  ldx #$17
.loop_field
  eor #%00000001
  sta $0452,x
  sta $04A2,x
  sta $04F2,x
  sta $0542,x
  sta $0592,x
  sta $05E2,x
  sta $0632,x
  sta $0682,x
  sta $06D2,x
  sta $0722,x
  tay
  pla
  eor #%00000001
  sta $047A,x
  sta $04CA,x
  sta $051A,x
  sta $056A,x
  sta $05BA,x
  sta $060A,x
  sta $065A,x
  sta $06AA,x
  sta $06FA,x
  sta $074A,x
  pha
  tya
  
  dex
  bpl .loop_field
  pla
  
  ; add right border
  
  lda #$07
  sta ZP_SCREENRAMADR+1
  lda #$B2
  sta ZP_SCREENRAMADR
  
  lda #$22
  ldx #$16
  ldy #$00

.loop_right_border
  sta (ZP_SCREENRAMADR),y
  pha
  lda ZP_SCREENRAMADR
  sec
  sbc #$28
  sta ZP_SCREENRAMADR
  lda ZP_SCREENRAMADR+1
  sbc #$00
  sta ZP_SCREENRAMADR+1
  pla
  eor #%00001110
  
  dex
  bne .loop_right_border
  
  ; add bottom border
  
  lda #$21
  ldx #$18
  
.loop_bottom_border
  sta $0771,x
  eor #%00001100
  dex
  bne .loop_bottom_border
  
  lda #$22
  sta $07B0
  lda #$20
  sta $0788
  
  rts
  

;********************************************************************************************************************************
;*** Draws the player statistic boxes
;********************************************************************************************************************************
!zone preparePlayerStatistics
preparePlayerStatistics

  lda #$2C
  ldx #$0B
  
  ; add the two long text fields (Points & Next)
.loop_long_text_fields
  sta $046C,x
  sta $04BC,x
  sta $078C,x
  sta $07DC,x
  
  lda #$21
  dex
  
  bpl .loop_long_text_fields

  lda #$20
  sta $046C
  sta $078C
  
  lda #$2D
  sta $04BC
  sta $07DC
  
  lda #$2E
  sta $04C7
  sta $07E7
  
  lda #$22
  sta $046C + $28
  sta $078C + $28
  sta $046D + $32
  sta $078D + $32
  
  ; add the two short text fields (Multi & Level)
  lda #$2C
  ldx #$07
  
.loop_short_text_fields
  sta $050E,x
  sta $055E,x
  
  lda #$21
  dex
  
  bpl .loop_short_text_fields

  lda #$20
  sta $050E
  
  lda #$2D
  sta $055E
  
  lda #$2E
  sta $0565
  
  lda #$22
  sta $050E + $28
  sta $050F + $2E
  
  ; write label points
  lda #<points_label
  sta ZP_SCREENTODRAW
  lda #>points_label
  sta ZP_SCREENTODRAW+1
  
  lda #$6D
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  lda #$D8
  sta ZP_COLORRAMADR+1
  ldy #$05
  ldx #COLOR_WHITE
  jsr write_text
  
  ; write label multi
  lda #$06
  jsr addToScreenToDraw
  
  lda #$0F
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$05
  sta ZP_SCREENRAMADR+1
  lda #$D9
  sta ZP_COLORRAMADR+1
  ldy #$04
  jsr write_text
  
  ; write label next
  lda #$05
  jsr addToScreenToDraw
  
  lda #$8D
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$07
  sta ZP_SCREENRAMADR+1
  lda #$DB
  sta ZP_COLORRAMADR+1
  ldy #$03
  jsr write_text
  
  ;write points number
  lda #$04
  jsr addToScreenToDraw
  
  lda #$95
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  lda #$D8
  sta ZP_COLORRAMADR+1
  ldy #$09
  jsr write_text
  
  ;write multi number
  lda #$0A
  jsr addToScreenToDraw
  
  lda #$39
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda #$05
  sta ZP_SCREENRAMADR+1
  lda #$D9
  sta ZP_COLORRAMADR+1
  ldy #$03
  jsr write_text
  
  rts
  
;********************************************************************************************************************************
;*** Draws predefined Text
;********************************************************************************************************************************
;*** Function parameters: Y(length of the text), X(color), ZP_SCREENTODRAW(position of the text), ZP_SCREENRAMADR(where to draw),
;***                      ZP_COLORRAMADR(where to color)
;********************************************************************************************************************************
;*** Returns: ---
;********************************************************************************************************************************
;*** changes: A, SR
;********************************************************************************************************************************
!zone write_text
write_text
  tya
  pha
.loop
  lda (ZP_SCREENTODRAW),y
  sta (ZP_SCREENRAMADR),y
  txa
  sta (ZP_COLORRAMADR),y
  dey
  bpl .loop
  
  pla
  tay
  rts
  
  
;*******************************************************************************
;***  Get random numbers from timer
;*******************************************************************************
;***  Function parameters: -
;*******************************************************************************
;***  Returns: Random number in A (which means Accumulator btw.)
;*******************************************************************************
;***  changes: A, SR(state register, this one stores information for the last operation, like overflow, if it was zero or if the carry flag was set)
;*******************************************************************************
!zone rndTimer                    ;time for another jump label zone
rndTimer                          ;name of the subroutine
  lda $dc04                       ;Low-Byte  of timer A from CIA-1 (lda load into A)
  eor $dc05                       ;High-Byte of timer A from CIA-1 (eor means exclusive or)
  eor $dd04                       ;Low-Byte  of timer A from CIA-2 (also eor)
  adc $dd05                       ;High-Byte of timer A from CIA-2 (adc is add the number in that address to A and add also the carry flag)
  eor $dd06                       ;Low-Byte  of timer B from CIA-2 (also eor)
  eor $dd07                       ;High-Byte of timer B from CIA-2 (also eor)
  rts                             ;return from subroutine

  
;*******************************************************************************
;***  Get modulo from Akku
;*******************************************************************************
;***  Function parameters: A(Divident), ZP_DIVISOR
;*******************************************************************************
;***  Returns: Modulo in Accumulator, QUOTIENT in x
;*******************************************************************************
;***  changes: A, X, (SR)
;*******************************************************************************  
!zone getModulo
getModulo
  ldx #$00
.loop
  inx
  sec
  sbc ZP_DIVISOR
  bpl .loop
  clc
  adc ZP_DIVISOR
  dex
  rts
  
  
;*******************************************************************************
;*** Eingabegerät wählen
;*******************************************************************************
;*** Übergabe: -
;*******************************************************************************
;*** Rückgabe: Gewähltes 'Gerät' in inputDevice
;*******************************************************************************
;*** ändert  : A, SR
;*******************************************************************************
!zone selectInputDevice
selectInputDevice
 lda #<CIA1_A                      ;Das LSB von CIA1_A (Port-2) hinter                                    
 sta joystickInput+1               ;den lda-Befehl bei joystickInput: ablegen
 jsr joystickInput                 ;und auf Eingabe prüfen
 and #JOY_FIRE                     ;Ist aktuell der Feuerknopf gedrückt?
 bne .joy1                         ;wenn nicht, weiter mit Port-1
 lda #INPUT_JOY2                   ;sonst, haben wir unseren Joystick
 sta inputDevice                   ;und merken es in inputDevice
.wait
 jsr joystickInput:                ;weiter den Joystick-2 prüfen
 and #JOY_FIRE                     ;ist immer noch Feuer gedrückt?
 beq .wait                         ;wenn ja, warte bis losgelassen
 rts                               ;und zurück
 
.joy1                              ;Wie eben, nur für den Joystick an Port-1
!zone joy1
 inc joystickInput+1               ;um CIA1_B zu verwenden reicht ein inc 
 jsr joystickInput
 and #JOY_FIRE
 bne .exit     
 lda #INPUT_JOY1
 sta inputDevice
.wait
 jsr joystickInput
 and #JOY_FIRE
 beq .wait
.exit
 rts                               ;zurück  
 

;*******************************************************************************
;*** Den ausgewählten Joystick abfragen
;*******************************************************************************
;*** Übergabe: CIA1_<PORT> an joystickInput:+1
;*******************************************************************************
;*** Rückgabe: A = aktueller Status
;***           inputState: = aktueller Status
;*******************************************************************************
;*** ändert  : A, SR
;*******************************************************************************
joystickInput:
 lda CIA1_A                        ;Aktuellen Status von Joy-1 oder 2 holen
                                   ;Nach der Joystick-Wahl speichern wir
                                   ;die richtige Adresse direkt hinterm lda
 
 rts                               ;zurück
 
 
;*******************************************************************************
;*** Joystickeingabe prüfen
;*** Prüft ob nur eine Richtung gedrückt ist und die Richtung aktuell erlaubt
;*** ist. Wenn beides zutrifft, wird die Eingabe über perfomInput verarbeitet.
;*******************************************************************************
;*** Übergabe: -
;*******************************************************************************
;*** Rückgabe: letzte Eingabe in inputState
;*******************************************************************************
;*** ändert  : A, X, Y, SR, inputState
;*******************************************************************************

!zone checkInput
checkInput
 jsr joystickInput                  ;Aktuellen Joystick-Status holen
 and #%00011111                     ;Nur die unteren 5-BIT sind von Interesse
 eor #%00011111                     ;Da Low-Aktiv, umkehren
 cmp inputState                     ;Neue Eingabe mit alter Eingabe vergleichen
 beq .exit                   ;Wenn gleich, dann exit
 
 sta inputState                     ;sonst merken wir uns den angepassten Wert                   
 
 lda #$01
 sta isPerformInput                 ;hier ist alles OK, also verarbeiten
 
.exit
 rts                                ;zurück
 
;********************************************************************************************************************************
;*** Checks the current input and sets the driving vehicle into the wanted direction
;********************************************************************************************************************************
!zone performInput
performInput

  lda #$00
  sta isPerformInput
  
  lda carList+$1B
  cmp #$FF
  bne .firstCarSet
  jmp .no_fire

.firstCarSet
  lda inputState
  
  ldx #$00
  ldy #$01
.loop_directions
  lsr
  bcc .next_direction
  pha                     ;found direction
  lda #$01
  sta gameTimer
  cpy carList+$1C
  bne .set_direction
  jsr turnCars            ;in opposite direction
  pla
  jmp .checkFire
.set_direction
  stx carList+$1C
  lda #$01
  jsr drawCar
  pla
  jmp .checkFire
.next_direction
  inx
  pha
  txa
  eor #%00000001
  tay
  pla
  cpx #$04
  bne .loop_directions
  
.checkFire
  lda inputState
  and #%00010000
  beq .no_fire
  lda gameTimerSpeed
  cmp gameTimeSlow
  beq .speed_up
;speed down
  lda gameTimeSlow
  sta gameTimerSpeed
  lda #$01
  sta gameTimer
  jmp .no_fire
.speed_up
  lda gameTimeFast
  sta gameTimerSpeed
  lda #$01
  sta gameTimer
  
.no_fire
  
  rts
  
  
;*******************************************************************************
;*** Dreht die Fahrzeugreihenfolge um
;*******************************************************************************
;*** Übergabe: --
;*******************************************************************************
;*** Rückgabe: --
;*******************************************************************************
;*** ändert  : A,X,Y,SR
;*******************************************************************************
!zone turnCars
turnCars
  
  ldy #$FD
  ldx #$1B
.loop_find_last
  iny
  iny
  iny
  
  lda carList,y
  cmp #$FF
  beq .loop_find_last
  
.loop_change_order
  lda carList,y
  sta tempCarList,x
  iny
  inx
  lda carList,y
  sta tempCarList,x
  iny
  inx
  lda carList,y
  sta tempCarList,x
  txa
  sec
  sbc #$05
  tax
  iny
  tya
  cmp #$1E
  bne .loop_change_order
  
  inx
  inx
.loop_copy_temp_to_cars
  lda tempCarList,x
  sta carList,x
  lda #$ff
  sta tempCarList,x
  inx
  txa
  cmp #$1E
  bne .loop_copy_temp_to_cars
  
;turn all cars to the opposite direction
  ldx #$1C
.loop_to_turn_all_cars
  lda carList,x
  cmp #$00
  bne .turn_car_up
  lda #$01
  sta carList,x
  jmp .check_for_next_loop
  
.turn_car_up
  cmp #$01
  bne .turn_car_right
  lda #$00
  sta carList,x
  jmp .check_for_next_loop
  
.turn_car_right
  cmp #$02
  bne .turn_car_left
  lda #$03
  sta carList,x
  jmp .check_for_next_loop
  
.turn_car_left
  lda #$02
  sta carList,x
  
.check_for_next_loop
  dex
  dex
  dex
  bpl .loop_to_turn_all_cars
  
;.exit
  rts

  
;*******************************************************************************
;*** Löscht ein Fahrzeug vom Spielfeld
;*******************************************************************************
;*** Übergabe: A (Nummer des Fahrzeugs)
;*******************************************************************************
;*** Rückgabe: --
;*******************************************************************************
;*** ändert  : A,X,Y,SR
;*******************************************************************************
!zone clearCar
clearCar

  tax
  lda #$1E
.carNumber_loop
  sec
  sbc #$03
  dex
  bne .carNumber_loop
  
  tax

  lda carList, X               ;get Position
  pha
  lsr
  lsr
  lsr
  lsr
  tax
  pla
  and #%00001111                
  tay                           ; now x is x and y is y

  jsr getCarPosition

  ldx #$20
  lda #$08
  sta ZP_COLORTODRAW
  jsr drawParkingLot
  
rts

!zone getCarPosition
getCarPosition

  lda ZP_PARKING_ROWS_L,y
  sta ZP_SCREENRAMADR
  lda ZP_PARKING_ROWS_H_S,y
  sta ZP_SCREENRAMADR+1
  
;.add_x
  txa
  asl
  jsr addToScreenAndColorRam

rts


;*******************************************************************************
;*** Zeichnet ein Fahrzeug auf das Spielfeld
;*******************************************************************************
;*** Übergabe: A (Nummer des Fahrzeugs)
;*******************************************************************************
;*** Rückgabe: --
;*******************************************************************************
;*** ändert  : A,X,Y,SR
;*******************************************************************************
!zone drawCar
drawCar
  
  tax
  lda #$20
.carNumber_loop
  sec
  sbc #$03
  dex
  bne .carNumber_loop
  
  tax
  lda carList, X
  sta ZP_COLORTODRAW
  
  dex
  lda carList, X               ;get direction
  sta ZP_HILFSVAR01
    
  dex
  lda carList, X               ;get Position
  tay
  lsr
  lsr
  lsr
  lsr
  tax
  tya
  and #%00001111                
  tay                           ; now x is x and y is y
  
  jsr getCarPosition
  
  lda ZP_HILFSVAR01
  cmp #$00
  bne .drawDown
  ldx #$28
  jmp .drawCar
  
.drawDown
  cmp #$01
  bne .drawLeft
  ldx #$38
  jmp .drawCar
  
.drawLeft
  cmp #$02
  bne .drawRight
  ldx #$24
  jmp .drawCar
  
.drawRight
  cmp #$03
  bne .exit
  ldx #$34
  
.drawCar
  jsr drawParkingLot
  
.exit
  rts
  
!zone drawParkingLot
drawParkingLot
  ldy #$00
  txa
  sta (ZP_SCREENRAMADR),y
  iny
  inx
  txa
  sta (ZP_SCREENRAMADR),y
  ldy #$28
  inx
  txa
  sta (ZP_SCREENRAMADR),y
  iny
  inx
  txa
  sta (ZP_SCREENRAMADR),y
  
;.drawColor
  ldy #$00
  lda ZP_COLORTODRAW
  sta (ZP_COLORRAMADR),y
  iny
  sta (ZP_COLORRAMADR),y
  ldy #$28
  sta (ZP_COLORRAMADR),y
  iny
  sta (ZP_COLORRAMADR),y
rts
  
;********************************************************************************************************************************
;*** Raster IRQ start right below the visible screen
;********************************************************************************************************************************
!zone rasterIRQ
rasterIRQ
  lda $d019
  
  bmi .doRasterIRQ
  lda $dc0d                           
  cli                                
  jmp $ea31 
  
.doRasterIRQ
  sei
  
  sta $d019
  lda #COLOR_BLACK
  sta $d020
  
  lda #$fd
  sta $d012
  lda $d011
  and #%01111111
  sta $d011
  
  lda isGameRunning
  bne .doGameRasterRoutine
;.doTitleRasterRoutine
  
  jsr alterPulse
  ldx #$00
  jsr playChannel
  ldx #$07
  jsr playChannel
  ldx #$0E
  jsr playChannel
  
  lda isPerformInput
  beq .playSounds
  
  lda #$00
  sta isPerformInput

  lda inputState
  and #%00010000
  beq .playSounds
  
  lda title_state
  bne .restartGame
  
  jsr drawHowTo
  jmp .playSounds
  
.restartGame
  jsr restartGame
  jmp .playSounds
  
.doGameRasterRoutine

  ;lda #COLOR_WHITE ;cpu time visualizing activate
  ;sta $d020
  
  ;add routines here
  lda isPerformInput
  beq .noInput
  jsr performInput
  
.noInput

  lda hasWhiteCars
  beq .countGameTimerDown
  
  lda gameTimer
  cmp carEffectTime1
  beq .clearWhiteCars
  cmp carEffectTime2
  beq .clearWhiteCars
  jmp .countGameTimerDown
  
  .clearWhiteCars
  jsr clearWhiteCars

.countGameTimerDown
  dec gameTimer
  bne .playSounds
  
  lda gameTimerSpeed
  sta gameTimer
  
  jsr moveCars
  
  lda isGameOver
  beq .checkAddCars
  jsr doGameOver
  
.checkAddCars
  lda isAddCars
  beq .checkCarPoints
  jsr setNextCar
  
.checkCarPoints
  lda isCheckCarsForPoints
  beq .playSounds
  jsr checkForCarPoints
  
  
.playSounds

  lda play_car_moving
  cmp #$04
  bne .stop_car_moving_sound
  
  lda #$68
  sta $d405
  lda #$16
  sta $d406
  lda #$0f
  sta $d418
  
  lda gameTimerSpeed
  cmp gameTimeFast
  beq .higher_note
  lda #SID_D_2_L
  sta $d400
  lda #SID_D_2_H
  sta $d401
  jmp .set_wave_form
.higher_note
    
  lda #SID_D_3_L
  sta $d400
  lda #SID_D_3_H
  sta $d401
  
.set_wave_form
  lda #$21
  sta $d404
  
  jmp .play_get_points_sound

.stop_car_moving_sound
  cmp #$01
  bne .play_get_points_sound
  lda #$20
  sta $d404
  
.play_get_points_sound
  
  lda play_get_points_sound
  cmp #$04
  bne .higher_points_note
  
  lda #$68
  sta $d405
  lda #$16
  sta $d406
  lda #$0f
  sta $d418
  
  lda #SID_D_6_L
  sta $d400
  lda #SID_D_6_H
  sta $d401
  jmp .set_points_wave_form
  
.higher_points_note
  cmp #$02
  bne .stop_points_sound
  
  lda #$68
  sta $d405
  lda #$16
  sta $d406
  lda #$0f
  sta $d418
  
  lda #SID_A_6_L
  sta $d400
  lda #SID_A_6_H
  sta $d401
  
.set_points_wave_form
  lda #$21
  sta $d404
  
  jmp .exitSoundRoutine

.stop_points_sound
  cmp #$01
  bne .exitSoundRoutine
  lda #$20
  sta $d404

.exitSoundRoutine
  lda play_car_moving
  beq .lower_points_sound_counter
  dec play_car_moving
  
.lower_points_sound_counter
  lda play_get_points_sound
  beq .exitRoutine
  dec play_get_points_sound
  
.exitRoutine
  ;end of routines
  
  ;lda #COLOR_BLACK ;cpu time visualizing deactivate
  ;sta $d020

  cli
  pla
  tay
  pla
  tax
  pla
  rti
  
  
!zone addToScreenAndColorRam
addToScreenAndColorRam

  clc
  adc ZP_SCREENRAMADR
  sta ZP_SCREENRAMADR
  sta ZP_COLORRAMADR
  lda ZP_SCREENRAMADR+1
  adc #$00
  sta ZP_SCREENRAMADR+1
  adc #$d4
  sta ZP_COLORRAMADR+1

rts
  
!zone clearWhiteCars
clearWhiteCars

  ldy #$16
  ldx #$0A
  
  lda #$52
  sta ZP_COLORRAMADR
  sta ZP_SCREENRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  lda #$d8
  sta ZP_COLORRAMADR+1
  
  
.loop_fields
  
  lda (ZP_COLORRAMADR),y
  and #%00001111
  cmp #$09
  bne .next_loop
  
  lda (ZP_SCREENRAMADR),y
  and #%11110000
  cmp #$40
  beq .delete_complete
  cmp #$50
  beq .delete_complete
  
;.make_ghostly

  tya
  pha
  clc
  lda (ZP_SCREENRAMADR),y
  adc #$20
  sta (ZP_SCREENRAMADR),y
  iny
  adc #$01
  pha
  sta (ZP_SCREENRAMADR),y
  tya
  adc #$27
  tay
  pla
  adc #$01
  sta (ZP_SCREENRAMADR),y
  iny
  adc #$01
  sta (ZP_SCREENRAMADR),y
  pla
  tay
  jmp .next_loop

.delete_complete
  tya
  pha
  lda #$20
  sta (ZP_SCREENRAMADR),y
  lda #$F8
  sta (ZP_COLORRAMADR),y
  iny
  sta (ZP_COLORRAMADR),y
  lda #$21
  sta (ZP_SCREENRAMADR),y
  tya
  clc
  adc #$27
  tay
  lda #$22
  sta (ZP_SCREENRAMADR),y
  lda #$F8
  sta (ZP_COLORRAMADR),y
  iny
  sta (ZP_COLORRAMADR),y
  lda #$23
  sta (ZP_SCREENRAMADR),y
  pla
  tay
  

.next_loop
  dey
  dey
  bpl .loop_fields
  
  lda #$50
  jsr addToScreenAndColorRam
  
  ldy #$16
  dex
  bpl .loop_fields
  

rts  

!zone doGameOver
doGameOver
  jsr init_song_0

  lda #$00
  sta isGameRunning
  
  jsr checkHighscore
  
  lda #COLOR_WHITE
  jsr fillScreenWithColor
  jsr drawTitleScreen

rts

!zone checkHighscore
checkHighscore

  lda #$10
  sta current_score                     ;delete current score marker for title screen

; first we have to get the number letters to the same letters, where the highscore letters are saved

  clc
  ldx #$09
.loop_change_numbers
  lda $0495,x
  adc #$60
  sta $0495,x
  dex
  bpl .loop_change_numbers
  
; now we beginn at the ending of the highscore and check if there is a smaller one
; therefore we check each number from the left if it is smaller in the highscore

  lda #$95                  ;load first number of reached highscore
  sta ZP_SCREENRAMADR
  lda #$04
  sta ZP_SCREENRAMADR+1
  
  lda #<highscore           ;load first number of last highscore
  adc #$46
  sta ZP_SCREENTODRAW
  lda #>highscore
  adc #$00
  sta ZP_SCREENTODRAW+1
  
  ldx #$04
.loop_through_highscores
  ldy #$00
.loop_through_numbers

  lda (ZP_SCREENRAMADR),y
  sta ZP_HILFSVAR01
  lda (ZP_SCREENTODRAW),y
  cmp ZP_HILFSVAR01
  beq .next_number
  bpl .get_to_current_entry
  
;.copy_score_one_down     ;reached highscore is higher
  tya
  pha
  
  sec
  lda ZP_SCREENTODRAW       ;go to letter number of lower highscore as source to copy
  sbc #$06
  sta ZP_SCREENTODRAW
  lda ZP_SCREENTODRAW+1
  sbc #$00
  sta ZP_SCREENTODRAW+1
  
  clc                       ;store first letter position of destination in helper var 01
  lda ZP_SCREENTODRAW
  adc #$10
  sta ZP_HILFSVAR01
  lda ZP_SCREENTODRAW+1
  adc #$00
  sta ZP_HILFSVAR02
  
  ldy #$0F                  ;copy
.loop_copy_score_down
  lda (ZP_SCREENTODRAW),y
  sta (ZP_HILFSVAR01),y
  dey
  bpl .loop_copy_score_down
  
  clc                     
  
  lda #$06
  jsr addToScreenToDraw     ;go back to first number of highscore
  
  pla
  tay
  
  jmp .next_score
  
.next_number
  iny
  cpy #$0A
  bne .loop_through_numbers

.next_score  
  sec
  lda ZP_SCREENTODRAW
  sbc #$10
  sta ZP_SCREENTODRAW
  lda ZP_SCREENTODRAW+1
  sbc #$00
  sta ZP_SCREENTODRAW+1
 
  txa
  sta current_score
  
  dex
  bpl .loop_through_highscores
  
.get_to_current_entry
  lda #$0A
  jsr addToScreenToDraw
  
  lda #$7A
  ldy #$00
  sta (ZP_SCREENTODRAW),y
  lda #$7B
  iny
  sta (ZP_SCREENTODRAW),y
  lda #$7C
  iny
  sta (ZP_SCREENTODRAW),y
  lda #$7F
  iny
  sta (ZP_SCREENTODRAW),y
  lda #$7F
  iny
  sta (ZP_SCREENTODRAW),y
  lda #$7F
  iny
  sta (ZP_SCREENTODRAW),y
  
  lda #$06
  jsr addToScreenToDraw
  
  ldy #$09

.loop_write_points

  lda (ZP_SCREENRAMADR),y
  sta (ZP_SCREENTODRAW),y

  dey
  bpl .loop_write_points
rts

!zone addToScreenToDraw
addToScreenToDraw

  clc
  adc ZP_SCREENTODRAW
  sta ZP_SCREENTODRAW
  lda ZP_SCREENTODRAW+1
  adc #$00
  sta ZP_SCREENTODRAW+1

rts

!zone restartGame
restartGame

  jsr stopTitleSong

  lda #$08
  jsr fillScreenWithColor
  jsr drawParkingLines
  jsr preparePlayerStatistics
  jsr setRandomCars
  jsr fillBoardWithRandomCars
  lda #$01
  sta player_multiplier
  sta isGameRunning
  sta isAddCars
  lda #$00
  sta isGameOver
  sta $D015     ; Sprite Visibility
  sta title_state
  
  lda #$FF
  ldx #$1E
.loop_clear_carList
  sta carList,x
  dex
  bpl .loop_clear_carList

rts
  
;********************************************************************************************************************************
;*** Testing for matched cars, deleting those cars and giving the player points
;********************************************************************************************************************************
!zone checkForCarPoints
checkForCarPoints

  lda #$00
  sta ZP_REMOVEDCARS

  dec isCheckCarsForPoints
  inc isAddCars
  
  ldx #$0A                      ;We set Y to the last line (it's in X because of performance)
  
  lda #$00
  sta ZP_HILFSVAR02
  
  lda #$DB
  sta ZP_COLORRAMADR+1
  lda #$72
  sta ZP_COLORRAMADR
  
.loop_y
  dex
  bpl .continue_y_loop
  jmp .calc_multiplier
.continue_y_loop
  lda ZP_COLORRAMADR
  sec
  sbc #$50
  sta ZP_COLORRAMADR
  lda ZP_COLORRAMADR+1
  sbc #$00
  sta ZP_COLORRAMADR+1
  ldy #$18                    ;### Caution X and Y are switched because of performance!!! ###
  
  lda #$00
  sta ZP_HILFSVAR01
  
  
.reset_color_count
  lda #$00
  sta ZP_HILFSVAR02
.loop_x
  dey                         ; X and Y are switched, because of peformance
  dey
  bmi .loop_y
  
  lda (ZP_COLORRAMADR),Y      ;lade Farbe
  and #%00001111
  cmp #08
  beq .reset_color_count
  cmp #09
  beq .reset_color_count
  
;.check_for_vertical_row
  sta ZP_HILFSVAR03
  tya
  pha
  txa
  cmp #$07
  bcs .check_square_n_horizontal
  
  tya
  clc
  adc #$50
  tay
  lda (ZP_COLORRAMADR),Y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .check_square_n_horizontal
  tya
  clc
  adc #$50
  tay
  lda (ZP_COLORRAMADR),Y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .check_square_n_horizontal
  lda ZP_COLORRAMADR+1
  sta ZP_HILFSVAR04
  tya
  clc
  adc #$50
  tay
  lda #$00
  adc ZP_COLORRAMADR+1
  sta ZP_COLORRAMADR+1
  lda (ZP_COLORRAMADR),Y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .set_back_color_ram_address
  
;.vertical found
  lda #$00
  sta ZP_HILFSVAR02
  sta ZP_HILFSVAR03
  lda ZP_HILFSVAR04
  sta ZP_COLORRAMADR+1
  pla
  pha
  tay
  jsr removeCarsAndGetPoints
  pla
  tay
  jmp .loop_x
  
.set_back_color_ram_address
  lda ZP_HILFSVAR04
  sta ZP_COLORRAMADR+1
.check_square_n_horizontal
  pla
  tay
  lda ZP_HILFSVAR03
  cmp ZP_HILFSVAR01
  bne .different_color
  inc ZP_HILFSVAR02
  lda ZP_HILFSVAR02
  cmp #$02
  bmi .loop_x
  
;.check_for_square
  tya
  pha
  
  clc
  adc #$50
  tay
  lda (ZP_COLORRAMADR), y
  and #%00001111
  cmp ZP_HILFSVAR01
  bne .check_for_four
  iny
  iny
  lda (ZP_COLORRAMADR), y
  and #%00001111
  cmp ZP_HILFSVAR01
  bne .check_for_four
;.square_found
  pla
  pha
  tay
  jsr removeCarsAndGetPoints
  lda #$00
  sta ZP_HILFSVAR02
  pla
  tay
  jmp .loop_x

.check_for_four
  pla
  tay
  lda ZP_HILFSVAR02
  cmp #$04
  beq .continue_check_for_four
  jmp .loop_x
  
.continue_check_for_four
;.horizontal found
  jsr removeCarsAndGetPoints
  lda #$00
  sta ZP_HILFSVAR02
  jmp .loop_x
.different_color
  sta ZP_HILFSVAR01
  lda #$01
  sta ZP_HILFSVAR02
  jmp .loop_x

.calc_multiplier
  lda ZP_REMOVEDCARS
  beq .halve_multiplier
  
  lda #$04
  sta play_get_points_sound
  
  lda player_multiplier
  clc
  adc ZP_REMOVEDCARS
  bcc .set_new_multiplier
;.set_max_multiplier
  lda #$FF
  sta player_multiplier 
  
  lda #$10
  sta $053C
  sta $053B
  sta $053A
  sta $0539
  sta $0538
  
  lda player_multiplier
  jmp .jump_over_add_one
  
.set_new_multiplier
  sta player_multiplier
  lda ZP_REMOVEDCARS
  
  ldx #$05
  ldy #$33
  jsr addNumberToString
  jmp .exit
  
.halve_multiplier

  lda #$10
  sta $053C
  sta $053B
  sta $053A
  lda #$1F
  sta $05379
  lda #$01
  sta $d93C
  sta $d93B
  sta $d93A
  sta $d939
  
  lda player_multiplier
  lsr
  bne .jump_over_add_one
  lda #$01
.jump_over_add_one
  sta player_multiplier
  
  ldx #$05
  ldy #$33
  jsr addNumberToString
  jmp .exit
.exit
rts



!zone addNumberToString
addNumberToString

  stx .loop_next_tenth+$02
  stx .loop_next_tenth+$05
  stx .loop_next_tenth+$0E
  
  sty .loop_next_tenth+$01
  sty .loop_next_tenth+$04
  sty .loop_next_tenth+$0D
  
  tay

.loop_add_points
  ldx #09
.loop_next_tenth
  inc $0495,x
  lda $0495,x
  cmp #$1A
  bne .next_number
  lda #$10
  sta $0495,x
  dex
  jmp .loop_next_tenth
.next_number
  dey
  bne .loop_add_points

rts

  

;********************************************************************************************************************************
;*** Removes the cars from the parking ground and gives points to the player for them
;********************************************************************************************************************************
;*** Übergabe: Y & ZP_COLORRAMADR as starting address
;*******************************************************************************
;*** Rückgabe: --
;*******************************************************************************
;*** ändert  : A, SR
;*******************************************************************************
!zone removeCarsAndGetPoints
removeCarsAndGetPoints

  tya
  pha
  sta ZP_HILFSVAR04           
  txa
  pha
  lda ZP_REMOVEDCARS
  pha
  lda #$00
  sta ZP_REMOVEDCARS
  
  lda ZP_COLORRAMADR          ; lade die niedrigeren bits der Fahrzeugzeile
  clc
  adc ZP_HILFSVAR04           ; addiere sie mit der X-Position des Fahrzeuges
  sta AUTOSTACK               ; lege die Position auf den Fahrzeug-Stack
  sta ZP_SCREENRAMADR         ; in den Zeichen-RAM-Zeiger 
  sta ZP_COLORRAMADR02        ; und in den Farb-RAM-Zeiger
  
  lda ZP_COLORRAMADR+1        ; lade die oberen bits der Fahrzeugzeile
  adc #$00                    ; addiere den carrier hinzu
  sta AUTOSTACK+1             ; lege das  in den Fahrzeug-Stack
  sta ZP_COLORRAMADR02+1      ; in den Farb-RAM-Zeiger
  sec
  sbc #$d4                    ; ziehe $D4 ab, um zum Zeichen-RAM-Bereich zu kommen
  sta ZP_SCREENRAMADR+1         ; schreibe das in den Zeichen-RAM-Zeiger
  
  ldy #$00
  lda (ZP_COLORRAMADR02),y
  and #%00001111
  sta ZP_HILFSVAR03
  
  ; remove first car from screen
  jsr clearCarFromScreen
  
  ldx #$00                      ; y is our pointer in our car position list
  
.loop_through_positions
  
  ;aktuelles Fahrzeug vom Fahrzeug-Stack holen
  lda AUTOSTACK,x
  sta ZP_COLORRAMADR02
  inx
  lda AUTOSTACK,x
  sta ZP_COLORRAMADR02+1
  dex
  dex
  dex
  inc ZP_REMOVEDCARS
  
  ldy #$00
  
  ;oberes Fahrzeug auf farbe prüfen
  lda ZP_COLORRAMADR02
  sec
  sbc #$50
  sta ZP_COLORRAMADR02
  lda ZP_COLORRAMADR02+1
  sbc #$00
  sta ZP_COLORRAMADR02+1
  lda (ZP_COLORRAMADR02),y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .check_left_car
  jsr putCarOnStackAndclear
  
  ;linkes Fahrzeug auf Farbe prüfen
.check_left_car
  lda ZP_COLORRAMADR02
  clc
  adc #$4E
  sta ZP_COLORRAMADR02
  lda ZP_COLORRAMADR02+1
  adc #$00
  sta ZP_COLORRAMADR02+1
  lda (ZP_COLORRAMADR02),y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .check_right_car
  jsr putCarOnStackAndclear
  
  ;rechtes Fahrzeug auf Farbe prüfen
.check_right_car
  lda ZP_COLORRAMADR02
  clc
  adc #$04
  sta ZP_COLORRAMADR02
  lda ZP_COLORRAMADR02+1
  adc #$00
  sta ZP_COLORRAMADR02+1
  lda (ZP_COLORRAMADR02),y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .check_bottom_car
  jsr putCarOnStackAndclear
  
  ;unteres Fahrzeug auf Farbe prüfen
.check_bottom_car
  lda ZP_COLORRAMADR02
  clc
  adc #$4E
  sta ZP_COLORRAMADR02
  lda ZP_COLORRAMADR02+1
  adc #$00
  sta ZP_COLORRAMADR02+1
  lda (ZP_COLORRAMADR02),y
  and #%00001111
  cmp ZP_HILFSVAR03
  bne .next_loop
  jsr putCarOnStackAndclear
  
.next_loop
  txa
  cmp #$FE
  bne .loop_through_positions
  
  jsr addPoints
  
  pla
  clc
  adc ZP_REMOVEDCARS
  sta ZP_REMOVEDCARS
  pla
  tax
  pla
  tay

rts
  

!zone addPoints
addPoints
  
  lda player_multiplier
  sta ZP_HILFSVAR04
  
.loop_through_multiplier
  ldx #$04
  ldy #$95
  lda ZP_REMOVEDCARS
  
  jsr addNumberToString
  dec ZP_HILFSVAR04
  bne .loop_through_multiplier
  
rts


!zone putCarOnStackAndclear
putCarOnStackAndclear
  inx
  inx
  
  lda ZP_COLORRAMADR02
  sta AUTOSTACK,x
  sta ZP_SCREENRAMADR
  inx
  lda ZP_COLORRAMADR02+1
  sta AUTOSTACK,x
  sec
  sbc #$D4
  sta ZP_SCREENRAMADR+1
  dex
  
  jsr clearCarFromScreen

rts

;********************************************************************************************************************************
;*** Removes car from the parking ground
;********************************************************************************************************************************
;*** Übergabe: ZP_COLORRAMADR02 & ZP_SCREENRAMADR
;*******************************************************************************
;*** Rückgabe: --
;*******************************************************************************
;*** ändert  : A, Y, SR
;*******************************************************************************
!zone clearCarFromScreen
clearCarFromScreen
  
  lda #$09
  ldy #$00
  sta (ZP_COLORRAMADR02),y
  iny
  sta (ZP_COLORRAMADR02),y
  ldy #$28
  sta (ZP_COLORRAMADR02),y
  iny
  sta (ZP_COLORRAMADR02),y
  
  lda #$01
  sta hasWhiteCars
  lda gameTimerSpeed
  sec
  sbc #$02
  sta carEffectTime1
  sbc #$02
  sta carEffectTime2

  rts

;********************************************************************************************************************************
;*** Set a new car onto the parking ground
;********************************************************************************************************************************
!zone setNextCar
setNextCar

  lda $0788
  cmp #$20
  beq .continue

  dec isAddCars
  inc isGameOver
  jmp .exitSetCar
  
.continue
  ldx #$1D
  ldy #$1B

.loop
  lda carList,y
  cmp #$FF
  beq .setCar
  dex
  dex
  dex
  dey
  dey
  dey
  bmi .exitSetCar
  bpl .loop
  
.setCar
  cpx #$1D
  bne .continue_set_car
  lda #$04
  sta play_car_moving
  
.continue_set_car
  lda #$BA
  sta carList,y

  dex
  lda #$00
  sta carList,x
  inx
  
  lda $DBB5
  sta carList,x
  
  sta $db88
  sta $db89
  sta $db88 + $28
  sta $db89 + $28
  
  lda #$28
  sta $0788
  lda #$29
  sta $0789
  lda #$2A
  sta $0788 + $28
  lda #$2B
  sta $0789 + $28
  
  lda player_multiplier
  
  ldx #$04
  ldy #$95
  jsr addNumberToString
  
  ldx #$00
  ldy #$01
  
.loop_next_cars
  lda $dbb5,y
  sta $dbb5,x
  lda $07b5,y
  sta $07b5,x
  inx
  iny
  tya
  cmp #$0A
  bne .loop_next_cars
  
  lda $07b5
  cmp #$41
  beq .exitSetCar
  
  ;all cars set
  
  dec isAddCars
  
  jsr setRandomCars
  
.exitSetCar
  
  rts
  
;********************************************************************************************************************************
;*** Let the cars drive over the parking ground
;********************************************************************************************************************************
!zone moveCars
moveCars

  lda carList + $1B           ;check if car 1 is set
  tax
  cmp #$FF
  bne .car_exists                   ;if not, exit
  jmp .exit
.car_exists
  lda carList + $1C           ;now check if direction is possible
  cmp #$00
  bne .checkDown
;check_up
  txa                         ;calc new X and Y
  and #%00001111              ;we calc y
  tay
  dey                         ; move into negative y (one position up)
  bmi .stopCars
  jmp .x_dir_possible
  
.checkDown
  cmp #$01
  bne .checkLeft
  txa                         ;calc new X and Y
  and #%00001111              ;we calc y
  tay
  iny                         ; move into negative y (one position up)
  tya
  cmp #$0A
  beq .stopCars
.x_dir_possible
  txa
  lsr
  lsr
  lsr
  lsr
  tax
  jmp .dir_is_possible
  
.checkLeft
  cmp #$02
  bne .checkRight
  txa                         ;calc new X and Y
  tay
  lsr
  lsr
  lsr
  lsr
  tax
  dex                         ; move into negative y (one position up)
  bmi .stopCars
  jmp .dir_is_possible
  
.checkRight
  txa                         ;calc new X and Y
  tay
  lsr
  lsr
  lsr
  lsr
  tax
  inx                         ; move into negative y (one position up)
  cpx #$0C
  beq .stopCars
.dir_is_possible
  txa
  and #%00001111
  tax
  tya
  and #%00001111
  tay
  ;push new position into car 1 in the car list
  
  sta ZP_DIVISOR
  txa
  asl
  asl
  asl
  asl
  ora ZP_DIVISOR              ; get new position number
  sta ZP_DIVISOR              ; push new car position to car 1 in carList
  
  jsr getCharAtPosition
  cmp #$20
  beq .setCars
  
.stopCars
  ;clear car list
  lda gameTimeSlow
  sta gameTimerSpeed
  lda #>carList
  sta ZP_SCREENRAMADR+1
  lda #<carList
  sta ZP_SCREENRAMADR
  
  ldy #$1D
  lda #$FF
.loop_clear_carList
  sta (ZP_SCREENRAMADR), Y
  dey
  bpl .loop_clear_carList
  
  ;get new cars
  inc isCheckCarsForPoints
  jmp .exit

  
.setCars
  ldx #$FD
  ldy #$0B
.loop_last_car
  dey
  inx
  inx
  inx
  
  ;searched through all cars?
  tya
  cmp #$00
  bne .isCarSet
  jmp .exit
.isCarSet
  ; is car set?
  lda carList,x
  cmp #$FF
  beq .loop_last_car
  ; found last car! y has car number
  txa
  pha
  tya
  pha
  jsr clearCar  ;clear last car from ground
  pla
  tay
  pla
  tax
  
  tya
  cmp #$01
  beq .setFirstCar
  
  ; set other cars one to the one in front of it
.loop_set_cars_to_new_position
  
  inx
  inx
  inx
  inx
  
  lda carList, x      ;lade Richtung des vorherigen Fahrzeugs
  sta ZP_HILFSVAR01
  dex                 
  lda carList, x      ;lade Position des vorherigen Fahrzeugs
  dex
  dex
  dex
  
  sta carList, x      ;schreibe neue Position des aktuellen Fahrzeugs
  inx
  lda ZP_HILFSVAR01
  sta carList, x      ;schreibe neue Richtung des aktuellen Fahrzeugs
  
  txa
  pha
  tya
  pha
  
  jsr drawCar         ;redraw current car
  
  pla
  tay
  pla
  tax
  
  inx
  inx
  
  dey
  tya
  cmp #$01
  bne .loop_set_cars_to_new_position ;continue until second car is set
  ;now we set the first car to its new position
.setFirstCar
  lda #$04
  sta play_car_moving
  
  lda ZP_DIVISOR
  sta carList + $1B
  lda #$01
  
  jsr drawCar         ;redraw current car

.exit
  rts 
  
;*******************************************************************************
;*** Lädt das Zeichen, dass sich auf der übergebenen Spielfeldstelle befindet
;*******************************************************************************
;*** Übergabe: X, Y
;*******************************************************************************
;*** Rückgabe: A (Char-Code des Zeichens in der linken oberen Ecke)
;*******************************************************************************
;*** ändert  : A, X, Y, SR
;*******************************************************************************
!zone getCharAtPosition
getCharAtPosition
  
  jsr getCarPosition
  ldy #$00
  lda (ZP_SCREENRAMADR),Y
  
  rts
  
;*******************************************************************************
;+++ Labels
;*******************************************************************************
  
points_label
  !byte $0D, $0C, $08, $0B, $1A, $0F
;multi_label
  !byte $03, $0C, $0A, $02, $0C
;next_label
  !byte $0B, $04, $1C, $1A
;points_number
  !byte $10, $10, $10, $10, $10, $10, $10, $10, $10, $10
;multi_number
  !byte $1F, $10, $10, $11
  
game_by_label
  !byte $07, $1D, $09, $1D, $1E, $0E, $1B, $04, $0E, $0C, $02
;fire_label
  !byte $05, $08, $0E, $04
;start_label
  !byte $0F, $1A, $01, $0E, $1A
  
how_to_label
  !byte $07, $0C, $30, $00, $1A, $0C, $00, $0D, $31, $01, $1D

;clear_cars_label
*=how_to_label+$50
  ;!byte $03, $31, $04, $01, $0E, $00, $03, $01, $0E, $0F, $00, $30, $08, $1A, $07, $00, $0E, $0C, $30, $0F, $00, $0B, $00, $03, $0C, $31, $0F, $00, $0C, $05, $00, $14
  !byte $03, $31, $04, $01, $0E, $00, $03, $01, $0E, $0F, $00, $02, $1D, $00, $0D, $01, $0E, $09, $08, $0B, $06, $00, $08, $0B, $00, $0E, $0C, $30, $0F, $1E, $03, $0C, $31, $0F

;squares_label
*=how_to_label+$78
  !byte $0C, $0E, $00, $0F, $33, $1B, $01, $0E, $04, $0F, $00, $0C, $05, $00, $14, $00, $04, $33, $1B, $01, $31, $00, $03, $0C, $31, $0C, $0E, $04, $32, $00, $03, $01, $0E, $0F

;raise_combo_label
*=how_to_label+$C8
  !byte $0E, $01, $08, $0F, $04, $00, $03, $0C, $0A, $02, $0C, $00, $02, $1D, $00, $03, $31, $04, $01, $0E, $08, $0B, $06, $00, $03, $01, $0E, $0F
*=how_to_label+$F0
  
;*******************************************************************************
;+++ Variables
;*******************************************************************************
inputDevice
  !byte $00
  
;*** Aktueller Status
inputState
  !byte $00
 
maxCars
  !byte $04
  
carList
  ; Car A: Position, Direction, Color  (Directions are $00 for up, $01 for down, $02 for left, $03 for right)
  !byte $FF,$00,$00
  ; Car 9
  !byte $FF,$00,$00
  ; Car 8
  !byte $FF,$00,$00
  ; Car 7
  !byte $FF,$00,$00
  ; Car 6
  !byte $FF,$00,$00
  ; Car 5
  !byte $FF,$00,$00
  ; Car 4
  !byte $FF,$00,$00
  ; Car 3
  !byte $FF,$00,$00
  ; Car 2
  !byte $FF,$00,$00
  ; Car 1
  !byte $FF,$00,$00
  
tempCarList
  ; Car A: Position, Direction, Color  (Directions are $00 for up, $01 for down, $02 for left, $03 for right)
  !byte $FF,$00,$00
  ; Car 9
  !byte $FF,$00,$00
  ; Car 8
  !byte $FF,$00,$00
  ; Car 7
  !byte $FF,$00,$00
  ; Car 6
  !byte $FF,$00,$00
  ; Car 5
  !byte $FF,$00,$00
  ; Car 4
  !byte $FF,$00,$00
  ; Car 3
  !byte $FF,$00,$00
  ; Car 2
  !byte $FF,$00,$00
  ; Car 1
  !byte $FF,$00,$00
  
isGameRunning
  !byte $00
  
title_state
  !byte $00
  
isGameOver
  !byte $00

isAddCars
  !byte $01
  
hasWhiteCars
  !byte $00
  
isCheckCarsForPoints
  !byte $00
  
isPerformInput
  !byte $00
  
gameTimer
  !byte $19

gameTimerSpeed
  !byte $19
  
gameTimeFast
  !byte $08
  
gameTimeSlow
  !byte $19
  
carEffectTime1
  !byte $00
carEffectTime2
  !byte $00
  
player_multiplier
  !byte $01
  
play_car_moving
  !byte $00
  
play_get_points_sound
  !byte $00
  
current_score
  !byte $10
  
highscore
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $72, $70, $70, $70
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $71, $70, $70, $70
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $70, $75, $70, $70
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $70, $71, $70, $70
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $70, $70, $75, $70
  !byte $7D, $7E, $7C, $7F, $7F, $7F, $70, $70, $70, $70, $70, $70, $70, $70, $70, $70

!zone stopTitleSong
stopTitleSong
  lda #$08
  sta $d404
  sta $d40B
  sta $d412
rts

!zone init_song_0
init_song_0

  lda #$03
  sta ZP_SID_CHANNEL_1_Timer
  sta ZP_SID_CHANNEL_2_Timer
  sta ZP_SID_CHANNEL_3_Timer
  sta ZP_SID_CHANNEL_1_Wave_Pos
  sta ZP_SID_CHANNEL_2_Wave_Pos
  sta ZP_SID_CHANNEL_3_Wave_Pos
  
  lda #$FF
  sta ZP_SID_CHANNEL_1_Pat_Pos
  sta ZP_SID_CHANNEL_2_Pat_Pos
  sta ZP_SID_CHANNEL_3_Pat_Pos
  
  lda #$00
  sta ZP_SID_CHANNEL_1_Channel_Pos
  sta ZP_SID_CHANNEL_2_Channel_Pos
  sta ZP_SID_CHANNEL_3_Channel_Pos
  
  lda #<wavetable
  sta ZP_WAVETABLE
  lda #>wavetable
  sta ZP_WAVETABLE+1
  
  ;Volume UP
  lda #$0F
  sta $d418
  
  ;ATTACK, DECAY, SUSTAIN, RELEASE of channel 1,2,3
  lda #$10
  sta $D405
  lda #$D0
  sta $D406
  
  lda #$20
  sta $D40C
  lda #$F5
  sta $D40D
  
  lda #$10
  sta $D413
  lda #$7F
  sta $D414
  
  ;set Pulse for ch3
  lda #$80
  sta $d410
  sta $d402
  sta ZP_SID_CHANNEL_3_Pulse_Lo
  lda #$08
  sta $d411
  sta $d403
  sta ZP_SID_CHANNEL_3_Pulse_Hi
  
  lda #<patt_00
  sta playChannel.pattern_use_1+1
  sta playChannel.pattern_use_2+1
  clc
  adc #$01
  sta playChannel.pattern_use_3+1
  lda #>patt_00
  pha
  adc #$00
  sta playChannel.pattern_use_3+2
  pla
  sta playChannel.pattern_use_1+2
  sta playChannel.pattern_use_2+2
  
rts

!zone alterPulse
alterPulse
  clc
  lda ZP_SID_CHANNEL_3_Pulse_Lo
  adc #$08
  sta ZP_SID_CHANNEL_3_Pulse_Lo
  lda ZP_SID_CHANNEL_3_Pulse_Hi
  adc #$00
  sta ZP_SID_CHANNEL_3_Pulse_Hi
  
  cmp #$0C
  bne .exit
  lda #$00
  sta ZP_SID_CHANNEL_3_Pulse_Lo
  lda #$06
  sta ZP_SID_CHANNEL_3_Pulse_Hi
  
.exit
  sta $d411
  lda ZP_SID_CHANNEL_3_Pulse_Lo
  sta $d410
rts

!zone playChannel
playChannel

  dec ZP_SID_CHANNEL_1_Timer, x
  beq .load_next_note
  jmp .play_wavetable
  
  
.load_next_note
  inc ZP_SID_CHANNEL_1_Pat_Pos, x ; goto next length and note
  lda ZP_SID_CHANNEL_1_Pat_Pos, x
  asl
  sta ZP_HILFSVAR01
  txa
  asl
  asl
  asl
  clc
  adc ZP_HILFSVAR01
  tay
.pattern_use_1
  lda patt_00,y
  cmp #$FF
  bne .set_note_length
  lda #$00
  sta ZP_SID_CHANNEL_1_Pat_Pos
  lda #$FF
  sta ZP_SID_CHANNEL_1_Pat_Pos+$07
  sta ZP_SID_CHANNEL_1_Pat_Pos+$0E
  inc ZP_SID_CHANNEL_1_Channel_Pos,x
  lda ZP_SID_CHANNEL_1_Channel_Pos,x
  asl
  tay
  lda channel1table, y
  cmp #$FF
  bne .set_pattern
  lda #$00
  sta ZP_SID_CHANNEL_1_Channel_Pos,x
  tay
  lda channel1table,y
.set_pattern
  sta .pattern_use_1+1
  sta .pattern_use_2+1
  clc
  adc #$01
  sta .pattern_use_3+1
  lda channel1table+1, y
  pha
  adc #$00
  sta .pattern_use_3+2
  pla
  sta .pattern_use_1+2
  sta .pattern_use_2+2
  txa
  asl
  asl
  asl
  tay
.pattern_use_2
  lda patt_00,y
  
.set_note_length
  jsr calc_note_length
  sta ZP_SID_CHANNEL_1_Timer,x
;set note
.pattern_use_3
  lda patt_00+1,y
  cmp #$FF
  bne .set_note_freq
;stop note from playing
  lda #$03 
  sta ZP_SID_CHANNEL_1_Wave_Pos,x
  lda #$08
  sta $d404,x
  jmp .exit
.set_note_freq
  asl
  tay
  lda notetable,y
  sta $D400,x
  lda notetable+1,y
  sta $D401,x
  txa
  sta ZP_SID_CHANNEL_1_Wave_Pos,x

.play_wavetable
  lda ZP_SID_CHANNEL_1_Wave_Pos,x
  tay
  lda (ZP_WAVETABLE),y
  beq .exit
  
  sta $d404,x
  iny
  sty ZP_SID_CHANNEL_1_Wave_Pos,x
  
.exit
  rts

!zone calc_note_length  
calc_note_length

  sta ZP_HILFSVAR04
  lda #$00
  
.loop_note_length
  adc #$06
  
  dec ZP_HILFSVAR04
  bne .loop_note_length
  sta ZP_HILFSVAR04
  
  lda ZP_HILFSVAR04
  
rts

wavetable
  !byte $81, $41, $80, $00, $00, $00, $00
  !byte $21, $21, $21, $21, $20, $00, $00
  !byte $41, $00

notetable
  !byte $5A,$04
  !byte $31,$04
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  
  !byte $E2,$04
  !byte $B5,$04
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  
  !byte $7C,$05
  !byte $48,$05
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  
  !byte $CF,$05
  !byte $98,$05
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  
  !byte $85,$06
  !byte $48,$06
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  !byte $00,$00
  
channel1table
  !byte <patt_00, >patt_00, <patt_00, >patt_00, <patt_01, >patt_01, <patt_01, >patt_01, <patt_02, >patt_02, <patt_02, >patt_02, <patt_03, >patt_03, <patt_03, >patt_03, $FF

patt_00
  !byte $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_00_ch_2
  !byte $02,$03, $0E,$03, $02,$0F, $0E,$0F, $02,$15, $0E,$15, $02,$03, $02,$0F, $02,$1B, $06,$04, $01,$03, $01,$09, $01,$0F, $01,$09, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_00_ch_3
  !byte $10,$01, $10,$0D, $10,$13, $01,$00, $03,$FF, $01,$19, $03,$FF, $02,$02, $02,$0E, $02,$02, $02,$FF, $FF
  
patt_01
  !byte $04,$00, $01,$00, $03,$02, $04,$00, $04,$02, $04,$00, $01,$00, $03,$02, $04,$00, $04,$02, $04,$00, $01,$00, $03,$02, $04,$00, $04,$02, $04,$00, $01,$00, $03,$02, $04,$00, $02,$02, $02,$02, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_01_ch_2
  !byte $02,$03, $04,$03, $0A,$04, $02,$0F, $04,$0F, $0A,$10, $02,$15, $04,$15, $0A,$16, $02,$03, $02,$0F, $02,$1B, $06,$04, $01,$03, $01,$09, $01,$0F, $01,$09, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_01_ch_3
  !byte $06,$FF, $03,$01, $03,$02, $02,$01, $02,$02, $06,$FF, $03,$0D, $03,$0E, $02,$0D, $02,$0E, $06,$FF, $03,$13, $03,$14, $02,$13, $02,$14, $08,$FF, $02,$02, $02,$19, $02,$0D, $02,$01, $FF,$FF

patt_02
  !byte $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $04,$00, $04,$02, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_01_ch_2
  !byte $02,$03, $04,$03, $0A,$04, $02,$0F, $04,$0F, $0A,$10, $02,$15, $04,$15, $0A,$16, $02,$03, $02,$0F, $02,$1B, $0A,$04, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_01_ch_3
  !byte $01,$01, $02,$0E, $01,$01, $02,$0E, $01,$01, $02,$0E, $01,$01, $03,$0E, $03,$02, $01,$0D, $02,$1A, $01,$0D, $02,$1A, $01,$0D, $02,$1A, $01,$0D, $03,$1A, $03,$0E, $01,$12, $02,$14, $03,$1A, $02,$14, $01,$0D, $02,$0E, $03,$14, $02,$0E, $01,$06, $02,$08, $03,$0E, $02,$08, $08,$02
  
patt_03
  !byte $04,$00, $01,$00, $01,$02, $03,$00, $03,$00, $04,$02, $04,$00, $01,$00, $01,$02, $03,$00, $03,$00, $04,$02, $04,$00, $01,$00, $01,$02, $03,$00, $03,$00, $04,$02, $04,$00, $01,$00, $01,$02, $0A,$00, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_03_ch02
  !byte $02,$03, $04,$03, $0A,$04, $02,$0F, $04,$0F, $0A,$10, $02,$15, $04,$15, $0A,$16, $02,$04, $02,$01, $02,$05, $02,$03, $02,$01, $02,$04, $02,$03, $02,$05, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF, $FF,$FF
;patt_03_ch03
  !byte $06,$01, $06,$03, $04,$04, $06,$0D, $06,$0F, $04,$10, $06,$13, $06,$15, $04,$16, $02,$1C, $02,$19, $02,$1D, $02,$1B, $02,$19, $02,$1C, $02,$1B, $02,$1D
;********************************************************************************************************************************
;*** own char ram
;********************************************************************************************************************************
*=$2000
  !media "ingame.charsetproject",char
  
!byte  $ff,$ff,$ff
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $01,$ff,$80
!byte  $00,$00,$00
!byte  $01,$ff,$c1
!byte  $01,$c1,$c3
!byte  $00,$00,$00
!byte  $01,$ff,$c6
!byte  $01,$ff,$8c
!byte  $00,$00,$00
!byte  $01,$80,$1f
!byte  $00,$00,$00
!byte  $01,$80,$3f
!byte  $01,$80,$70
!byte  $00,$00,$00
!byte  $01,$80,$e0
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $07,$ff,$ff
!byte  $00,$00,$00
!byte  $02,$ff,$ff
!byte  $ff,$00,$00
!byte  $00,$00,$00
!byte  $00,$00,$ff
!byte  $e6,$00,$00
!byte  $00,$00,$ff
!byte  $f6,$80,$c0
!byte  $76,$00,$00
!byte  $00,$c0,$ff
!byte  $e6,$60,$c1
!byte  $c6,$00,$00
!byte  $00,$f0,$c0
!byte  $67,$00,$00
!byte  $00,$f8,$c0
!byte  $67,$1c,$c0
!byte  $67,$00,$00
!byte  $00,$0e,$c0
!byte  $77,$00,$00
!byte  $00,$00,$00
!byte  $00,$ff,$ff
!byte  $ff,$00,$00
!byte  $00,$02,$ff
!byte  $ff,$ff,$00
!byte  $00,$00,$00
!byte  $00,$00,$03
!byte  $99,$c0,$00
!byte  $00,$00,$06
!byte  $19,$e0,$0e
!byte  $19,$f0,$00
!byte  $00,$00,$18
!byte  $19,$f8,$30
!byte  $19,$bc,$00
!byte  $00,$00,$fc
!byte  $19,$8f,$00
!byte  $00,$00,$ce
!byte  $19,$87,$86
!byte  $19,$83,$00
!byte  $00,$00,$03
!byte  $99,$80,$00
!byte  $00,$00,$00
!byte  $00,$00,$ff
!byte  $ff,$ff,$00
!byte  $1f,$ff,$02
!byte  $ff,$ff,$ff
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $c7,$fc,$03
!byte  $00,$00,$00
!byte  $cf,$fe,$03
!byte  $cc,$00,$00
!byte  $00,$00,$00
!byte  $dc,$7e,$00
!byte  $dc,$7f,$00
!byte  $00,$00,$00
!byte  $dc,$07,$00
!byte  $00,$00,$00
!byte  $cc,$07,$00
!byte  $cf,$ff,$00
!byte  $00,$00,$00
!byte  $c7,$fe,$00
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $ff,$ff,$ff
!byte  $ff,$ff,$ff
!byte  $02,$ff,$ff
!byte  $ff,$00,$00
!byte  $00,$00,$00
!byte  $00,$ff,$98
!byte  $ff,$00,$00
!byte  $00,$ff,$99
!byte  $ff,$18,$19
!byte  $80,$00,$00
!byte  $00,$18,$1b
!byte  $80,$18,$1b
!byte  $80,$00,$00
!byte  $00,$18,$1b
!byte  $80,$00,$00
!byte  $00,$18,$19
!byte  $80,$18,$19
!byte  $ff,$00,$00
!byte  $00,$18,$18
!byte  $ff,$00,$00
!byte  $00,$00,$00
!byte  $00,$ff,$ff
!byte  $ff,$ff,$f0
!byte  $00,$02,$ff
!byte  $ff,$ff,$00
!byte  $00,$00,$00
!byte  $00,$00,$98
!byte  $0e,$3f,$00
!byte  $00,$00,$98
!byte  $18,$7f,$18
!byte  $30,$60,$00
!byte  $00,$00,$18
!byte  $e0,$7f,$19
!byte  $c0,$7f,$00
!byte  $00,$00,$1f
!byte  $e0,$60,$00
!byte  $00,$00,$1f
!byte  $38,$60,$9e
!byte  $1c,$7f,$00
!byte  $00,$00,$98
!byte  $0e,$3f,$00
!byte  $00,$00,$00
!byte  $00,$00,$ff
!byte  $ff,$ff,$00
!byte  $00,$00,$02
!byte  $ff,$ff,$ff
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $e7,$ff,$00
!byte  $00,$00,$00
!byte  $e7,$ff,$00
!byte  $00,$30,$00
!byte  $00,$00,$00
!byte  $e0,$30,$00
!byte  $e0,$30,$00
!byte  $00,$00,$00
!byte  $00,$30,$00
!byte  $00,$00,$00
!byte  $00,$30,$00
!byte  $e0,$30,$00
!byte  $00,$00,$00
!byte  $e0,$30,$00
!byte  $00,$00,$00
!byte  $00,$00,$00
!byte  $ff,$ff,$e0
!byte  $00,$00,$00
!byte  $02
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  